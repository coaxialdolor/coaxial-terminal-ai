# >>> TERMINALAI SHELL INTEGRATION START
# Added by TerminalAI (https://github.com/coaxialdolor/terminalai)
# This shell function enables seamless stateful command execution.
# Prompts and errors from the Python script are sent to stderr and are visible in the terminal.
function global:ai {
    [CmdletBinding(SupportsShouldProcess=$true)]
    Param(
        [Parameter(Mandatory=$false, ValueFromRemainingArguments=$true)]
        [string[]]$Arguments
    )

    Set-Variable -Name TERMINALAI_SHELL_INTEGRATION -Value "1" -Scope Global -Force

    if ($Arguments.Count -gt 0 -and $Arguments[0] -ne "--chat" -and $Arguments[0] -ne "-c" -and $Arguments[0] -ne "--setup" -and $Arguments[0] -ne "--set-default" -and $Arguments[0] -ne "--set-ollama" -and $Arguments[0] -notmatch "^--(provider|yes|verbose|long|version|help)") {
        # Direct query / eval mode path
        $queryStringFromArgs = $Arguments -join " "
        $aiCommandPath = (Get-Command -Name ai -CommandType Application -ErrorAction Stop | Select-Object -First 1).Source
        if (-not $aiCommandPath) {
            Write-Error "Could not resolve path for 'ai' command. Ensure it's in your PATH."
            return
        }

        $LiteralQuote = [char]34
        $processInfo = New-Object System.Diagnostics.ProcessStartInfo
        $processInfo.FileName = $aiCommandPath
        $processInfo.Arguments = "--eval-mode $($LiteralQuote)$queryStringFromArgs$($LiteralQuote)"
        $processInfo.UseShellExecute = $false
        $processInfo.RedirectStandardOutput = $true
        $processInfo.RedirectStandardError = $true
        $processInfo.RedirectStandardInput = $true # Added for stdin hang issue

        $process = New-Object System.Diagnostics.Process
        $process.StartInfo = $processInfo

        try {
            $process.Start() | Out-Null
            $process.StandardInput.Close() # Close stdin stream
            $process.WaitForExit()

            $outputToEval = $process.StandardOutput.ReadToEnd()
            $errorOutputFromAI = $process.StandardError.ReadToEnd()
            $aiExitCode = $process.ExitCode

            if ($errorOutputFromAI) {
                [System.Console]::Error.Write($errorOutputFromAI)
            }

            if ($aiExitCode -eq 0) {
                if ($outputToEval -and $outputToEval.Trim().Length -gt 0) {
                    Invoke-Expression $outputToEval.Trim()
                }
            }
        } catch {
            Write-Error "Error executing 'ai': $_"
        } finally {
            Remove-Variable -Name TERMINALAI_SHELL_INTEGRATION -Scope Global -ErrorAction SilentlyContinue
            $process.Dispose()
        }
    } else {
        # Interactive, chat, or setup mode path
        $aiCommandPath = (Get-Command -Name ai -CommandType Application -ErrorAction Stop | Select-Object -First 1).Source
        if (-not $aiCommandPath) {
            Write-Error "Could not resolve path for 'ai' command. Ensure it's in your PATH."
            return
        }
        & $aiCommandPath @Arguments # Pass all original arguments
        Remove-Variable -Name TERMINALAI_SHELL_INTEGRATION -Scope Global -ErrorAction SilentlyContinue
    }
}
# <<< TERMINALAI SHELL INTEGRATION END